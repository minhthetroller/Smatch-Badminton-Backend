generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [uuid_ossp(map: "uuid-ossp"), pg_trgm]
}

/// Courts table - stores badminton court information
model Court {
  /// Secure UUID primary key
  id String @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid

  /// BASIC INFO
  name        String  @db.VarChar(255)
  description String? @db.Text

  /// CONTACT - Array of phone numbers
  phoneNumbers String[] @map("phone_numbers") @db.Text

  /// ADDRESS (Split columns)
  addressStreet   String? @map("address_street") @db.VarChar(255)
  addressWard     String? @map("address_ward") @db.VarChar(100)
  addressDistrict String? @map("address_district") @db.VarChar(100)
  addressCity     String? @default("Hà Nội") @map("address_city") @db.VarChar(100)

  /// GOOGLE MAPS STYLE DETAILS (JSONB)
  /// Stores: Amenities, Payments, Service Options, Highlights, etc.
  details Json @default("{}") @db.JsonB

  /// OPENING HOURS (JSONB)
  /// Format: {"mon": "07:00-22:00", "tue": "07:00-22:00", ...}
  openingHours Json @default("{}") @map("opening_hours") @db.JsonB

  /// LOCATION (PostGIS) - Using Unsupported for GEOGRAPHY type
  /// Stores the coordinate point for the Interactive Map
  location Unsupported("geography(Point, 4326)")?

  /// METADATA
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  /// RELATIONS
  subCourts    SubCourt[]    @relation("CourtSubCourts")
  pricingRules PricingRule[] @relation("CourtPricingRules")
  matches      Match[]       @relation("CourtMatches")

  @@index([addressDistrict], map: "idx_courts_district")
  @@index([details(ops: JsonbOps)], map: "idx_courts_details", type: Gin)
  @@map("courts")
}

/// SubCourt - Individual playable courts within a venue
model SubCourt {
  id          String  @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  courtId     String  @map("court_id") @db.Uuid
  name        String  @db.VarChar(100)
  description String? @db.Text
  isActive    Boolean @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  /// RELATIONS
  court    Court             @relation("CourtSubCourts", fields: [courtId], references: [id], onDelete: Cascade)
  closures SubCourtClosure[] @relation("SubCourtClosures")
  bookings Booking[]         @relation("SubCourtBookings")

  @@index([courtId], map: "idx_sub_courts_court_id")
  @@map("sub_courts")
}

/// SubCourtClosure - Track exceptions when a sub-court is unavailable
model SubCourtClosure {
  id         String    @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  subCourtId String    @map("sub_court_id") @db.Uuid
  date       DateTime  @db.Date
  startTime  DateTime? @map("start_time") @db.Time() // NULL = full day closure
  endTime    DateTime? @map("end_time") @db.Time() // NULL = full day closure
  reason     String?   @db.VarChar(255)

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  /// RELATIONS
  subCourt SubCourt @relation("SubCourtClosures", fields: [subCourtId], references: [id], onDelete: Cascade)

  @@index([subCourtId, date], map: "idx_sub_court_closures_lookup")
  @@map("sub_court_closures")
}

/// PricingRule - Tiered pricing at court level
model PricingRule {
  id           String   @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  courtId      String   @map("court_id") @db.Uuid
  name         String   @db.VarChar(100)
  dayType      String   @map("day_type") @db.VarChar(20) // 'weekday', 'weekend', 'holiday'
  startTime    DateTime @map("start_time") @db.Time()
  endTime      DateTime @map("end_time") @db.Time()
  pricePerHour Int      @map("price_per_hour") // Price in VND
  isActive     Boolean  @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  /// RELATIONS
  court Court @relation("CourtPricingRules", fields: [courtId], references: [id], onDelete: Cascade)

  @@index([courtId, dayType, isActive], map: "idx_pricing_rules_court")
  @@map("pricing_rules")
}

/// Booking - Track reservations per sub-court and time slot
model Booking {
  id         String   @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  subCourtId String   @map("sub_court_id") @db.Uuid
  userId     String?  @map("user_id") @db.Uuid // FK to users table
  guestName  String?  @map("guest_name") @db.VarChar(255)
  guestPhone String?  @map("guest_phone") @db.VarChar(20)
  guestEmail String?  @map("guest_email") @db.VarChar(255)
  date       DateTime @db.Date
  startTime  DateTime @map("start_time") @db.Time()
  endTime    DateTime @map("end_time") @db.Time()
  totalPrice Int      @map("total_price") // Calculated from pricing_rules
  status     String   @default("pending") @db.VarChar(20) // pending, confirmed, cancelled, completed, failed
  notes      String?  @db.Text
  groupId    String?  @map("group_id") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  /// RELATIONS
  subCourt SubCourt  @relation("SubCourtBookings", fields: [subCourtId], references: [id], onDelete: Cascade)
  user     User?     @relation("UserBookings", fields: [userId], references: [id], onDelete: SetNull)
  payments Payment[] @relation("BookingPayments")

  @@index([subCourtId, date, status], map: "idx_bookings_sub_court_date")
  @@index([date, startTime, endTime], map: "idx_bookings_date_range")
  @@index([userId], map: "idx_bookings_user_id")
  @@index([groupId], map: "idx_bookings_group_id")
  @@map("bookings")
}

/// PaymentType - Type of payment
enum PaymentType {
  BOOKING      // Court booking payment
  MATCH_JOIN   // Match join fee payment
}

/// Payment - Track ZaloPay payment transactions
model Payment {
  id           String      @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  bookingId    String?     @map("booking_id") @db.Uuid // Optional - for booking payments
  matchPlayerId String?    @map("match_player_id") @db.Uuid // Optional - for match join payments
  paymentType  PaymentType @default(BOOKING) @map("payment_type") // Type of payment
  appTransId   String      @unique @map("app_trans_id") @db.VarChar(40) // ZaloPay transaction ID (yymmdd_xxx)
  zpTransId    String?     @map("zp_trans_id") @db.VarChar(20) // ZaloPay's transaction ID (from callback)
  zpTransToken String?     @map("zp_trans_token") @db.VarChar(256) // Token for ZaloPay mobile SDK
  amount       Int         // Amount in VND
  status       String      @default("pending") @db.VarChar(20) // pending, success, failed, expired
  orderUrl     String?     @map("order_url") @db.Text // ZaloPay order URL for QR code
  callbackData Json?       @map("callback_data") @db.JsonB // Store raw callback for debugging

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  /// RELATIONS
  booking     Booking?     @relation("BookingPayments", fields: [bookingId], references: [id], onDelete: Cascade)
  matchPlayer MatchPlayer? @relation("MatchPlayerPayments", fields: [matchPlayerId], references: [id], onDelete: Cascade)

  @@index([bookingId], map: "idx_payments_booking_id")
  @@index([matchPlayerId], map: "idx_payments_match_player_id")
  @@index([status], map: "idx_payments_status")
  @@index([paymentType], map: "idx_payments_type")
  @@map("payments")
}

/// Holiday - Track holidays for pricing rules
model Holiday {
  id         String   @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  date       DateTime @unique @db.Date
  name       String?  @db.VarChar(255)
  multiplier Float    @default(1.0) // Price multiplier for this holiday (e.g., 1.5 = 50% increase)

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@index([date], map: "idx_holidays_date")
  @@map("holidays")
}

/// User - Store user authentication and profile information
model User {
  id          String  @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  firebaseUid String  @unique @map("firebase_uid") @db.VarChar(128)

  /// AUTHENTICATION
  email       String? @unique @db.VarChar(255)
  username    String? @unique @db.VarChar(50)
  provider    String  @db.VarChar(50) // google, facebook, password, anonymous
  isAnonymous Boolean @default(false) @map("is_anonymous")

  /// PERSONAL INFORMATION
  firstName   String? @map("first_name") @db.VarChar(100)
  lastName    String? @map("last_name") @db.VarChar(100)
  gender      String? @db.VarChar(20) // male, female, other, prefer_not_to_say
  phoneNumber String? @map("phone_number") @db.VarChar(20)
  photoUrl    String? @map("photo_url") @db.Text

  /// ADDRESS (Optional, split fields like Court)
  addressStreet   String? @map("address_street") @db.VarChar(255)
  addressWard     String? @map("address_ward") @db.VarChar(100)
  addressDistrict String? @map("address_district") @db.VarChar(100)
  addressCity     String? @default("Hà Nội") @map("address_city") @db.VarChar(100)

  /// METADATA
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  /// PUSH NOTIFICATIONS
  fcmTokens String[] @default([]) @map("fcm_tokens") @db.Text

  /// RELATIONS
  bookings      Booking[]      @relation("UserBookings")
  hostedMatches Match[]        @relation("HostedMatches")
  matchPlayers  MatchPlayer[]  @relation("UserMatchPlayers")

  @@index([firebaseUid], map: "idx_users_firebase_uid")
  @@index([email], map: "idx_users_email")
  @@index([username], map: "idx_users_username")
  @@map("users")
}

// ==================== MATCH (Exchange) MODELS ====================

/// SkillLevel - Player skill levels for matching
enum SkillLevel {
  TBY        // Tập bóng yếu (Beginner weak)
  Y          // Yếu (Weak)
  Y_PLUS     // Yếu+ (Weak+)
  Y_PLUS_PLUS // Yếu++ (Weak++)
  TBK        // Trung bình khá (Average-good)
  TB         // Trung bình (Average)
  TB_PLUS    // Trung bình+ (Average+)
  TB_PLUS_PLUS // Trung bình++ (Average++)
  K          // Khá (Good)
  K_PLUS     // Khá+ (Good+)
  GIOI       // Giỏi (Excellent)
}

/// ShuttleType - Shuttlecock brands/types
enum ShuttleType {
  TC77
  BASAO
  YONEX_AS30
  YONEX_AS40
  YONEX_AS50
  VICTOR_MASTER_1
  VICTOR_CHAMPION_1
  RSL_CLASSIC
  LINDAN_40
  LINDAN_50
  OTHER
}

/// PlayerFormat - Match format for players
enum PlayerFormat {
  SINGLE_MALE       // Nam đơn
  SINGLE_FEMALE     // Nữ đơn
  DOUBLE_MALE       // Nam đôi
  DOUBLE_FEMALE     // Nữ đôi
  MIXED_DOUBLE      // Đôi nam nữ
  ANY               // Linh hoạt
}

/// MatchStatus - Status of a match
enum MatchStatus {
  OPEN       // Looking for players
  FULL       // All slots filled
  IN_PROGRESS // Match is happening
  COMPLETED  // Match finished
  CANCELLED  // Match cancelled
}

/// MatchPlayerStatus - Status of a player in a match
enum MatchPlayerStatus {
  PENDING         // Waiting for host approval (private match)
  PENDING_PAYMENT // Waiting for payment (after approval or for public match with fee)
  ACCEPTED        // Approved and paid (or free match)
  REJECTED        // Rejected by host
  LEFT            // Player left the match
  EXPIRED         // Payment expired
}

/// Match - Exchange match for finding players
model Match {
  id          String      @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  
  /// RELATIONS
  courtId     String      @map("court_id") @db.Uuid
  hostUserId  String      @map("host_user_id") @db.Uuid
  
  /// BASIC INFO
  title       String?     @db.VarChar(255)
  description String?     @db.Text
  images      String[]    @default([]) @db.Text // S3 URLs
  
  /// MATCH DETAILS
  skillLevel  SkillLevel  @map("skill_level")
  shuttleType ShuttleType @map("shuttle_type")
  playerFormat PlayerFormat @map("player_format")
  
  /// SCHEDULE
  date        DateTime    @db.Date
  startTime   DateTime    @map("start_time") @db.Time()
  endTime     DateTime    @map("end_time") @db.Time()
  
  /// SETTINGS
  isPrivate   Boolean     @default(false) @map("is_private") // Requires approval to join
  price       Int         @default(0) // Price per player in VND
  slotsNeeded Int         @default(1) @map("slots_needed") // Number of players needed
  
  /// STATUS
  status      MatchStatus @default(OPEN)
  
  /// METADATA
  createdAt   DateTime    @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime    @default(now()) @updatedAt @map("updated_at") @db.Timestamptz
  
  /// RELATIONS
  court       Court       @relation("CourtMatches", fields: [courtId], references: [id], onDelete: Cascade)
  host        User        @relation("HostedMatches", fields: [hostUserId], references: [id], onDelete: Cascade)
  players     MatchPlayer[] @relation("MatchPlayers")
  
  @@index([courtId], map: "idx_matches_court_id")
  @@index([hostUserId], map: "idx_matches_host_user_id")
  @@index([date, status], map: "idx_matches_date_status")
  @@index([skillLevel, status], map: "idx_matches_skill_status")
  @@map("matches")
}

/// MatchPlayer - Players joining a match
model MatchPlayer {
  id          String            @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  
  /// RELATIONS
  matchId     String            @map("match_id") @db.Uuid
  userId      String            @map("user_id") @db.Uuid
  
  /// STATUS
  status      MatchPlayerStatus @default(PENDING)
  message     String?           @db.Text // Optional message when requesting to join
  
  /// POSITION (for ordering accepted players)
  position    Int?              // 1, 2, 3, 4 for doubles etc.
  
  /// TIMESTAMPS
  requestedAt DateTime          @default(now()) @map("requested_at") @db.Timestamptz
  respondedAt DateTime?         @map("responded_at") @db.Timestamptz
  
  /// RELATIONS
  match       Match             @relation("MatchPlayers", fields: [matchId], references: [id], onDelete: Cascade)
  user        User              @relation("UserMatchPlayers", fields: [userId], references: [id], onDelete: Cascade)
  payments    Payment[]         @relation("MatchPlayerPayments")
  
  @@unique([matchId, userId], map: "idx_match_players_unique")
  @@index([matchId, status], map: "idx_match_players_match_status")
  @@index([userId], map: "idx_match_players_user_id")
  @@map("match_players")
}