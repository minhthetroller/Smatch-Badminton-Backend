generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [uuid_ossp(map: "uuid-ossp"), pg_trgm]
}

/// Courts table - stores badminton court information
model Court {
  /// Secure UUID primary key
  id String @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid

  /// BASIC INFO
  name        String  @db.VarChar(255)
  description String? @db.Text

  /// CONTACT - Array of phone numbers
  phoneNumbers String[] @map("phone_numbers") @db.Text

  /// ADDRESS (Split columns)
  addressStreet   String? @map("address_street") @db.VarChar(255)
  addressWard     String? @map("address_ward") @db.VarChar(100)
  addressDistrict String? @map("address_district") @db.VarChar(100)
  addressCity     String? @default("Hà Nội") @map("address_city") @db.VarChar(100)

  /// GOOGLE MAPS STYLE DETAILS (JSONB)
  /// Stores: Amenities, Payments, Service Options, Highlights, etc.
  details Json @default("{}") @db.JsonB

  /// OPENING HOURS (JSONB)
  /// Format: {"mon": "07:00-22:00", "tue": "07:00-22:00", ...}
  openingHours Json @default("{}") @map("opening_hours") @db.JsonB

  /// LOCATION (PostGIS) - Using Unsupported for GEOGRAPHY type
  /// Stores the coordinate point for the Interactive Map
  location Unsupported("geography(Point, 4326)")?

  /// METADATA
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  /// RELATIONS
  subCourts    SubCourt[]    @relation("CourtSubCourts")
  pricingRules PricingRule[] @relation("CourtPricingRules")

  @@index([addressDistrict], map: "idx_courts_district")
  @@index([details(ops: JsonbOps)], map: "idx_courts_details", type: Gin)
  @@map("courts")
}

/// SubCourt - Individual playable courts within a venue
model SubCourt {
  id          String  @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  courtId     String  @map("court_id") @db.Uuid
  name        String  @db.VarChar(100)
  description String? @db.Text
  isActive    Boolean @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  /// RELATIONS
  court    Court             @relation("CourtSubCourts", fields: [courtId], references: [id], onDelete: Cascade)
  closures SubCourtClosure[] @relation("SubCourtClosures")
  bookings Booking[]         @relation("SubCourtBookings")

  @@index([courtId], map: "idx_sub_courts_court_id")
  @@map("sub_courts")
}

/// SubCourtClosure - Track exceptions when a sub-court is unavailable
model SubCourtClosure {
  id         String    @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  subCourtId String    @map("sub_court_id") @db.Uuid
  date       DateTime  @db.Date
  startTime  DateTime? @map("start_time") @db.Time() // NULL = full day closure
  endTime    DateTime? @map("end_time") @db.Time() // NULL = full day closure
  reason     String?   @db.VarChar(255)

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  /// RELATIONS
  subCourt SubCourt @relation("SubCourtClosures", fields: [subCourtId], references: [id], onDelete: Cascade)

  @@index([subCourtId, date], map: "idx_sub_court_closures_lookup")
  @@map("sub_court_closures")
}

/// PricingRule - Tiered pricing at court level
model PricingRule {
  id           String   @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  courtId      String   @map("court_id") @db.Uuid
  name         String   @db.VarChar(100)
  dayType      String   @map("day_type") @db.VarChar(20) // 'weekday', 'weekend', 'holiday'
  startTime    DateTime @map("start_time") @db.Time()
  endTime      DateTime @map("end_time") @db.Time()
  pricePerHour Int      @map("price_per_hour") // Price in VND
  isActive     Boolean  @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  /// RELATIONS
  court Court @relation("CourtPricingRules", fields: [courtId], references: [id], onDelete: Cascade)

  @@index([courtId, dayType, isActive], map: "idx_pricing_rules_court")
  @@map("pricing_rules")
}

/// Booking - Track reservations per sub-court and time slot
model Booking {
  id         String   @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  subCourtId String   @map("sub_court_id") @db.Uuid
  userId     String?  @map("user_id") @db.Uuid // FK to users table
  guestName  String?  @map("guest_name") @db.VarChar(255)
  guestPhone String?  @map("guest_phone") @db.VarChar(20)
  guestEmail String?  @map("guest_email") @db.VarChar(255)
  date       DateTime @db.Date
  startTime  DateTime @map("start_time") @db.Time()
  endTime    DateTime @map("end_time") @db.Time()
  totalPrice Int      @map("total_price") // Calculated from pricing_rules
  status     String   @default("pending") @db.VarChar(20) // pending, confirmed, cancelled, completed
  notes      String?  @db.Text

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  /// RELATIONS
  subCourt SubCourt  @relation("SubCourtBookings", fields: [subCourtId], references: [id], onDelete: Cascade)
  user     User?     @relation("UserBookings", fields: [userId], references: [id], onDelete: SetNull)
  payments Payment[] @relation("BookingPayments")

  @@index([subCourtId, date, status], map: "idx_bookings_sub_court_date")
  @@index([date, startTime, endTime], map: "idx_bookings_date_range")
  @@index([userId], map: "idx_bookings_user_id")
  @@map("bookings")
}

/// Payment - Track ZaloPay payment transactions
model Payment {
  id           String   @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  bookingId    String   @map("booking_id") @db.Uuid
  appTransId   String   @unique @map("app_trans_id") @db.VarChar(40) // ZaloPay transaction ID (yymmdd_xxx)
  zpTransId    String?  @map("zp_trans_id") @db.VarChar(20) // ZaloPay's transaction ID (from callback)
  zpTransToken String?  @map("zp_trans_token") @db.VarChar(256) // Token for ZaloPay mobile SDK
  amount       Int      // Amount in VND
  status       String   @default("pending") @db.VarChar(20) // pending, success, failed, expired
  orderUrl     String?  @map("order_url") @db.Text // ZaloPay order URL for QR code
  callbackData Json?    @map("callback_data") @db.JsonB // Store raw callback for debugging

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  /// RELATIONS
  booking Booking @relation("BookingPayments", fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([bookingId], map: "idx_payments_booking_id")
  @@index([status], map: "idx_payments_status")
  @@map("payments")
}

/// Holiday - Track holidays for pricing rules
model Holiday {
  id         String   @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  date       DateTime @unique @db.Date
  name       String?  @db.VarChar(255)
  multiplier Float    @default(1.0) // Price multiplier for this holiday (e.g., 1.5 = 50% increase)

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@index([date], map: "idx_holidays_date")
  @@map("holidays")
}

/// User - Store user authentication and profile information
model User {
  id          String  @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  firebaseUid String  @unique @map("firebase_uid") @db.VarChar(128)

  /// AUTHENTICATION
  email       String? @unique @db.VarChar(255)
  username    String? @unique @db.VarChar(50)
  provider    String  @db.VarChar(50) // google, facebook, password, anonymous
  isAnonymous Boolean @default(false) @map("is_anonymous")

  /// PERSONAL INFORMATION
  firstName   String? @map("first_name") @db.VarChar(100)
  lastName    String? @map("last_name") @db.VarChar(100)
  gender      String? @db.VarChar(20) // male, female, other, prefer_not_to_say
  phoneNumber String? @map("phone_number") @db.VarChar(20)
  photoUrl    String? @map("photo_url") @db.Text

  /// ADDRESS (Optional, split fields like Court)
  addressStreet   String? @map("address_street") @db.VarChar(255)
  addressWard     String? @map("address_ward") @db.VarChar(100)
  addressDistrict String? @map("address_district") @db.VarChar(100)
  addressCity     String? @default("Hà Nội") @map("address_city") @db.VarChar(100)

  /// METADATA
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  /// RELATIONS
  bookings Booking[] @relation("UserBookings")

  @@index([firebaseUid], map: "idx_users_firebase_uid")
  @@index([email], map: "idx_users_email")
  @@index([username], map: "idx_users_username")
  @@map("users")
}